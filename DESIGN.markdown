Design notes
============

Here is a rationale for some design decisions and implementation details.
Not all of the sketched features are implemented and not everything
is implemented as described.


Level generation
----------------

Each level is generated by an algorithm inspired by the original Rogue,
as follows:

  * The available area is divided into a 3 by 3 grid
    where each of the 9 grid cells has approximately the same size.

  * In each of the 9 grid cells one room is placed at a random location.
    The minimum size of a room is 2 by 2 floor tiles. A room is surrounded
    by walls, and the walls still have to fit into the assigned grid cells.

  * Rooms that are on horizontally or vertically adjacent grid cells
    may be connected by a corridor. Corridors consist of 3 segments of straight
    lines (either "horizontal, vertical, horizontal" or "vertical, horizontal,
    vertical"). They end in openings in the walls of the room they connect.
    It is possible that one or two of the 3 segments have length 0, such that
    the resulting corridor is L-shaped or even a single straight line.

  * Corridors are generated randomly in such a way that at least every room
    on the grid is connected, and a few more might be. It is not sufficient
    to always connect all adjacent rooms.

  * Stairs up and down are placed. Stairs are always located in two different
    randomly chosen rooms.


Field Of View
-------------

The algorithm used is a variant of Shadow Casting. We first specify
fields that are reachable from the player. As input to the algorithm,
we require information about fields that block light. As output,
we get information on the reachability of all fields.
We assume that the player is located at position (0, 0)
and we only consider fields (line, row) where line 0 and 0 row line.
This is just about one eighth of the whole player surroundings,
but the other parts can be computed in the same fashion by mirroring
or rotating the given algorithm accordingly.

      fov (blocks, maxline) =
         shadow := \empty_set
         reachable (0, 0) := True
         for l \in [ 1 .. maxline ] do
            for r \in [ 0 .. l ] do
              reachable (l, r) := ( \exists a. a \in interval (l, r) \and
                                    a \not_in shadow)
              if blocks (l, r) then
                 shadow := shadow \union interval (l, r)
              end if
            end for
         end for
         return reachable

      interval (l, r) = return [ angle (l + 0.5, r - 0.5),
                                 angle (l - 0.5, r + 0.5) ]
      angle (l, r) = return atan (r / l)

The algorithm traverses the fields line by line, row by row.
At every moment, we keep in shadow the intervals which are in shadow,
measured by their angle. A square is reachable when any point
in it is not in shadow --- the algorithm is permissive in this respect.
We could also require that a certain fraction of the field is reachable,
or a specific point. Our choice has certain consequences. For instance,
a single blocking field throws a shadow, but the fields immediately behind
the blocking field are still visible.

We can compute the interval of angles corresponding to one square field
by computing the angle of the line passing the upper left corner
and the angle of the line passing the lower right corner.
This is what interval and angle do. If a field is blocking, the interval
for the square is added to the shadow set.

Once we compute the reachable fields using FOV, it is possible
to compute what the player can actually see. Fields adjacent to the player
(also diagonally) can always be seen (except for walls).
Fields that have light and are reachable can also be seen.
We treat floor of rooms as having light, whereas corridors and rock are dark.

Walls reflect light. They can be seen only if an adjacent floor field
can also be seen. In particular, walls cannot be seen when passing
a corridor on the outside of a room, but can be seen from the inside of a room.


Monster movement
----------------

Not all monsters use the same algorithm to find the player.
Some implemented and unimplemented methods are listed below:

* Random
The simplest way to have a monster move is at random.

* Sight
If a monster can see the player (as an approximation,
we assume it is the case when the player can see the monster),
the monster should move toward the player.

* Smell
The player leaves a trail when moving toward the dungeon.
For a certain timespan (100--200 moves), it is possible
for certain monsters to detect that a player has been at a certain field.
Once a monster is following a trail, it should move to the
neighboring field where the player has most recently visited.

* Noise
The player makes noise. If the distance between the player
and the monster is small enough, the monster can hear the player
and moves into the approximate direction of the player.
